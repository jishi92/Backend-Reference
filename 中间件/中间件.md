# 消息队列
## 消息丢了怎么办？
1，消费者丢了：   
因为消费者进程异常导致消息未被正常处理，可以关闭自动ack机制，当处理完消息之后再主动ack。  

2,mq丢了：   
某个broker宕机切换leader时导致数据丢失。解决方法：设置每个分区至少两个副本；设置leader至少有一个follower保持联系；设置生产者必须写入所有副本才算写入成功否则一直重试；  

开启持久化结合confirm机制；

3，生产者丢了：    
生产者写入失败后一直重试；
confirm机制：消息持久化到磁盘才会通知生产者ack了。接收到nack或超时会重发。confirm机制是异步的。
事务机制：发送前开启事务，如果消息没有被mq接收到则回滚事务，收到了则提交事务。事务机制是同步阻塞的会降低性能。

![](http://blog.itpub.net/ueditor/php/upload/image/20190428/1556440399299024.jpg)

## 消息重复了怎么办？
消费者设计时保证幂等性。

# php与nginx的交互
Nginx -> FastCGI -> php-fpm -> FastCGI Wrapper -> php解析器

step1：用户将http请求发送给nginx服务器(用户和nginx服务器进行三次握手进行TCP连接)   
step2：nginx会根据用户访问的URI和后缀对请求进行判断   
step3：通过第二步可以看出，用户请求的是动态内容，nginx会将请求交给fastcgi客户端，通过fastcgi_pass将用户的请求发送给php-fpm，如果用户访问的是静态资源nginx直接将用户请求的静态资源返回给用户。  
step4：wrapper收到php-fpm转过来的请求后，wrapper会生成一个新的线程调用php动态程序解析服务器。  
step5：php会将查询到的结果返回给nginx  
step6：nginx构造一个响应报文将结果返回给用户  

nginx和php交互是通过fastcgi,CGI是通用网关协议，FastCGI则是一种常住进程的CGI模式程序。PHP-FPM的全称是PHP FastCGI Process Manager，即PHP-FPM会通过用户配置来管理一批FastCGI进程，例如在PHP-FPM管理下的某个FastCGI进程挂了，PHP-FPM会根据用户配置来看是否要重启补全，PHP-FPM更像是管理器，而真正衔接Nginx与PHP的则是FastCGI进程。

![](http://img1.sycdn.imooc.com/596e56910001ae5d05590315.png)

FastCgi的下游cgi-app即是PHP程序，上游则是nginx。fastcgi_pass所配置的内容，便是告诉Nginx你接收到用户请求以后，你该往哪里转发。

Nginx与PHP的两种通信方式-unix socket和tcp socket。
unix socket减少了不必要的tcp开销，而tcp需要经过loopback，还要申请临时端口和tcp相关资源。但是，unix socket高并发时候不稳定，连接数爆发时，会产生大量的长时缓存，在没有面向连接协议的支撑下，大数据包可能会直接出错不返回异常。tcp这样的面向连接的协议，多少可以保证通信的正确性和完整性。


# NGINX

## 作用
1，反向代理
2，动静分离
3，负载均衡


## nginx如何实现负载均衡的？
负载均衡的作用：  
1，转发功能：根据转发规则将请求转发到不同的服务器上，提高系统的并发量。   
2，故障移除：判断应用服务器当前是否可以正常工作，如果服务器期宕掉，自动将请求发送到其他应用服务器。  
3，恢复添加：如检测到发生故障的应用服务器恢复工作，自动将其添加到处理用户请求队伍中。


nginx的负载均衡策略可以划分为两大类：内置策略和扩展策略。  
内置策略包含加权轮询和ip hash，在默认情况下这两种策略会编译进nginx内核，只需在nginx配置中指明参数即可。  
扩展策略有很多，如fair、通用hash、consistent hash等，默认不编译进nginx内核。  

1，轮询（默认）  
每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 

2，指定权重：  
指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 
3，根据ip进行hash
这样每个访客固定访问一个后端服务器，可以解决session的问题。  
4，fair：按后端服务器的响应时间来分配请求，响应时间短的优先分配。 
5，url_hash

## nginx 进程模型
![](https://pics5.baidu.com/feed/4a36acaf2edda3cc99daac7c7fa1cd04213f927a.jpeg?token=81fa13dd47ee33474454eda213004055&s=3AA87C2391CE49EB4EF551CF0100E0A1)  

Nginx 里有一个 master 进程和多个 worker 进程。master 进程并不处理网络请求，主要负责调度工作进程：加载配置、启动工作进程及非停升级。worker 进程负责处理网络请求与响应。

包含：
1、接收来自外界的信号，向各worker进程发送信号。

2、监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。

而基本的网络事件，则是放在worker进程中来处理了。worker进程之间是对等的，一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。
worker进程的个数，一般会设置与机器cpu核数一致。当我们提供80端口的http服务时，一个连接请求过来，每个进程都有可能处理这个连接。

master处理过程如下：

master（master进程会先建立好需要listen的socket）--------fork生成子进程workers，继承socket（此时workers子进程们都继承了父进程master的所有属性）。一般来说，当一个连接进来后，所有在accept在这个socket上面的进程，都会收到通知，而只有一个进程可以accept这个连接，其它的则accept失败。



惊群现象：指一个fd的事件被触发后，等候这个fd的所有线程/进程都被唤醒。虽然都被唤醒，但是只有一个会去响应。最常见的例子就是对于socket的accept操作，当多个用户进程/线程监听在同一个端口上时，由于实际只可能accept一次，因此就会产生惊群现象。惊群现象可以通过accept_mutex加锁来避免。

### nginx如何实现高性能的？   
1，事件驱动模型：基于异步及非阻塞的事件驱动模型，可以说是 Nginx 得以获得高并发、高性能的关键因素。   
2，多进程模型：   
（1）进程之间不共享资源，不需要加锁，减少了使用锁对性能造成的影响，同时降低编程的复杂度，降低开发成本。  
（2）采用独立的进程，可以让进程互相之间不会影响，如果一个进程发生异常退出时，其它进程正常工作，master 进程则很快启动新的 worker 进程，确保服务不会中断，从而将风险降到最低。   
3，内存池：  
它的作用主要是把多次向系统申请内存的操作整合成一次，这大大减少了 CPU 资源的消耗，同时减少了内存碎片。  
4，模块化设计：  
高度模块化的设计是 Nginx 的架构基础。

## nginx的事件处理机制
对于一个基本的web服务器来说，事件通常有三种类型：网络事件、信号、定时器。Nginx采用异步非阻塞的事件处理机制，由进程循环处理多个准备好的事件，从而实现高并发和轻量级。

nginx高并发处理：采用异步非阻塞的事件处理机制。之所以能够并发处理大量的未处理完的请求，是通过异步非阻塞方式，由进程循环处理多个准备好的事件。以epoll为例，为准备好的事件都会放入epoll中，只要有事件准备好，就会进行处理。

### 为何推荐worker的个数为cpu的个数？
        
回答：因为更多的worker数，只会导致进程相互竞争cpu资源，从而带来不必要的上下文切换。


## nginx和Apache的比较
Nginx比较Apache：事件驱动适合于IO密集型服务，多进程或线程适合于CPU密集型服务


1）Nginx更主要是作为反向代理，而非Web服务器使用。其网络模式是事件驱动（select、poll、epoll）。

2）事件驱动的本质还是IO事件，应用程序在多个IO句柄间快速切换，实现所谓的异步IO。

3）事件驱动服务器，最适合做的就是这种IO密集型工作，如反向代理，它在客户端与WEB服务器之间起一个数据中转作用，纯粹是IO操作，自身并不涉及到复杂计算。

4）反向代理用事件驱动来做，显然更好，一个工作进程就可以run了，没有进程、线程管理的开销，CPU、内存消耗都小。

5）当然，Nginx也可以是多进程 + 事件驱动的模式，几个进程跑libevent，不需要Apache那样动辄数百的进程数。

6）Nginx处理静态文件效果也很好，那是因为静态文件本身也是磁盘IO操作，处理过程一样。
## location的匹配规则
匹配的顺序是先匹配普通字符串，然后再匹配正则表达式。另外普通字符串匹配顺序是根据配置中字符长度从长到短，也就是说使用普通字符串配置的location顺序是无关紧要的，反正最后nginx会根据配置的长短来进行匹配，但是需要注意的是正则表达式按照配置文件里的顺序测试。找到第一个比配的正则表达式将停止搜索。




1."="前缀指令匹配，如果匹配成功，则停止其他匹配
2.普通字符串指令匹配，顺序是从长到短，匹配成功的location如果使用^~，则停止其他匹配（正则匹配）
3.正则表达式指令匹配，按照配置文件里的顺序，成功就停止其他匹配
4.如果第三步中有匹配成功，则使用该结果，否则使用第二步结果


## PHP框架比较

## 设计模式

## PHP与go的比较

## RPC框架 

## 一致性算法(raft)，一致性哈希


