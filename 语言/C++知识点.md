# 大小端

大端模式：指数据的高字节保存在内存的低地址

小端模式：指数据的高字节保存在内存的高地址

![](https://img-blog.csdn.net/20180821180140124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbG9keV8xMDE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

写程序判断思路：想办法取出一个字节的内容，就可以知道是哪种存储方式。比如，i变量是4个字节，我们只要取出它的第一个字节内容，如果是78，则说明是小端存储；反之是大端。

	 char*p = (char*)(&i);

关于“取出一个字节的内容”，有两种办法：

（1）用指针的办法：把变量的地址强制类型转换为char*,这样就可以每次取出一个字节的内容

（2）用联合的知识：在联合体中定义一个char 类型的变量和int类型的变量，利用二者所占同一段存储空间，可以通过引用联合体变量中的成员访问char 类型的数据。取出一个字节的内容
————————————————
版权声明：本文为CSDN博主「melody_jae」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/melody_1016/article/details/81910873

----------
# 智能指针
四种：auto_ptr, shared_ptr, weak_ptr, unique_ptr  

使用智能指针可以很大程度上的避免忘记释放内存导致的内存泄露问题，因为智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。  

断一个智能指针是否为空不能使用if(ptest == NULL)，应该使用if(ptest.get() == NULL)  

unique_ptr：是用于取代c++98的auto_ptr的产物，是一个独享所有权的智能指针。    
shared_ptr：share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享。  
weak_ptr是用来解决shared_ptr相互引用时的死锁问题，它是对对象的一种弱引用，不会增加对象的引用计数，和shared_ptr之间可以相互转化。  


----------
# const和define的区别

(1) 编译器处理方式不同  

	　　define宏是在预处理阶段展开。  
	　　const常量是编译运行阶段使用。   
(2) 类型和安全检查不同   

	　　define宏没有类型，不做任何类型检查，仅仅是展开。  
	　　const常量有具体的类型，在编译阶段会执行类型检查。   
(3) 存储方式不同  

	　　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。（宏定义不分配内存，变量定义分配内存。）  
	　　const常量会在内存中分配(可以是堆中也可以是栈中)。   
(4)const 可以节省空间，避免不必要的内存分配。  

	const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，
	所以，const定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 #define定义的常量在内存中有若干个拷贝。   

 C++ 语言可以用const来定义常量，也可以用 #define来定义常量。但是前者比后者有更多的优点：

（1）   const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应）。

（2）   有些集成化的调试工具可以对const常量进行调试，但是不能对宏常量进行调试。

const定义的常量在超出其作用域之后其空间会被释放，而static定义的静态常量在函数执行后不会释放其存储空间。

----------


# char (*p)[]和char *p[]的区别

1. []的优先级高于 * , (*p）[]理解为指向一个数组，  
*(p[])存放指针的数组

2. char (*p)[SIZE]：指向一维数组的指针，一维数组只能有SIZE个元素

    char *p[SIZE]：指针数组，数组有SIZE个元素


----------

# volatile关键字作用
遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt; 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。   

volatile 可以保证对特殊地址的稳定访问。  

多线程下：volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。


----------


# 指针和引用的区别
引用是别名，指针是地址。
1，指针在运行时可以改变所指向的值，而引用一旦与某个对象绑定后就不再改变。意思是：指针可以被重新赋值以指向另一个对象，但是引用则总是在初始化时被指定的对象，以后不能改变，但是指向的内容可以改变。  
2，程序为指针变量分配区域，而不为引用分配内存区域。因为引用生命时必须初始化，从而指向一个已经存在的对象，引用不能为空值。  
3，程序在编译时分别将指针和引用添加到符号表上，符号表上记录的是变量名及变量所对应地址。指针可以改变指向的对象（指针变量中的值可以改），而引用对象不能改。这是使用指针不安全而使用引用安全的主要原因。从某种意义上来说引用可以被认为是不能改变的指针。  
4，理论上来说，对于指针没有级数限制，但是引用只有一级。  
5，两者的效率是一致的，在底层中，指针和引用的参数都指向同一个地址。  
在高级编程语言中，因为用*传参可能会指向空的地址或者错误的地址，所以要时时判断参数是否为空，导致降低效率。
而用&传参数，则参数不可能为空或者错误地址，这也算稍微提升了一些效率。  

----------


# atoi字符串转换成整形

    int my_atoi(char* pstr)
	{
	int Ret_Integer = 0;
	int Integer_sign = 1;
	
	/*
	* 判断指针是否为空
	*/
	if(pstr == NULL)
	{
		printf("Pointer is NULL\n");
		return 0;
	}	
	/*
	* 跳过前面的空格字符
	*/
	while(isspace(*pstr) == 0)
	{
		pstr++;
	}	
	/*
	* 判断正负号
	* 如果是正号，指针指向下一个字符
	* 如果是符号，把符号标记为Integer_sign置-1，然后再把指针指向下一个字符
	*/
	if(*pstr == '-')
	{
		Integer_sign = -1;
	}
	if(*pstr == '-' || *pstr == '+')
	{
		pstr++;
	}	
	/*
	* 把数字字符串逐个转换成整数，并把最后转换好的整数赋给Ret_Integer
	*/
	while(*pstr >= '0' && *pstr <= '9')
	{
		Ret_Integer = Ret_Integer * 10 + *pstr - '0';
		pstr++;
	}
	Ret_Integer = Integer_sign * Ret_Integer;
	
	return Ret_Integer;


----------

# 内存分配

对于一个完整的程序，在内存中的分布情况如下：　
1.栈区： 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。   
2.堆区：就是那些由 new 分配的内存块，他们的释放编译器不去管，delete.  
3.自由存储区:就是那些由 malloc 等分配的内存块，他和堆是十分相似的，不过它是用 free 来结束自己的生命的。   
4.全局数据区(静态区)：全局变量和静态便令的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束释放。  
5.常量存储区:这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改.
https://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html


----------

# 虚函数机制
虚函数(virtual function)是通过一个虚函数表(virtual table )来实现的，虚函数表里存储的是每个虚函数的地址。
虚函数表主要是一个虚函数查找表，主要是在运行时根据指针对象或者引用对象的类型调用相应的虚函数。虚函数表其实是存储了为类对象进行声明的虚函数地址。

**缺点：**如果某个类不包含虚函数，那一般是表示它将不作为一个基类来使用。当一个类不准备作为基类使用时，使析构函数为虚一般是个坏主意。因为它会为类增加一个虚函数表，对象增加一个虚指针，使得对象的体积增大。所以当且仅当类里包含至少一个虚函数的时候才去声明虚析构函数。


----------

# static用法
## 1，局部静态变量：  
用于函数体内部修饰变量，这种变量的生存期一直到程序关闭。  
作用域：函数体内部， 生存期：整个程序运行期间。  
（1）该变量在全局数据区分配内存(局部变量在栈区分配内存);
（2）静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化(局部变量每次函数调用都会被初始化);
（3）静态局部变量一般在声明处初始化，如果没有显式初始化，会被程序自动初始化为0(局部变量不会被初始化);
（4）它始终驻留在全局数据区，直到程序运行结束。但其作用域为局部作用域，也就是不能在函数体外面使用它(局部变量在栈区，在函数结束后立即释放内存);

## 2，全局静态变量  
定义在函数体外，用于修饰全局变量，表示该变量只在本文件可见。
作用域：该文件内部， 生存期：整个程序运行期间。  

静态全局变量不能被其它文件所用(全局变量可以);

## 3，静态成员函数  
用于修饰 class 的成员函数。静态函数属于类的，不属于某一个具体的对象。访问方式，可以通过对像调用，也可以用类名::函数名进行访问。  
普通的成员函数总是具体的属于某个类的具体对象，所以普通的成员函数一般都隐含了一个this指针，this指针指向类的对象本身。但是静态成员函数由于不予任何的对象相关联，因此它不具有this指针。因而无法访问类对象的非静态成员函数，也无法访问静态成员函数，只能调用其余的静态成员函数与访问静态数据成员。另外，因为static成员不是任何对象的组成部分，所以static成员函数不能被声明为const。  
另外，static成员函数也不能被声明为虚函数、volatile。

## 为什么引入static
想将函数中的变量保存到下一次调用，但又不想破坏变量的访问范围。
所以，当需要一个数据对象为整个类而非某个对象服务，同时又力求不破坏类的封装性，即要求该成员隐藏在类的内部不对外可见。


----------
# 堆栈溢出的原因
1.函数调用层次太深。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。
2.动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。
3.数组访问越界。C语言没有提供数组下标越界检查，如果在程序中出现数组下标访问超出数组范围，在运行过程中可能会内存访问错误。
4.指针非法访问。指针保存了一个非法的地址，通过这样的指针访问所指向的地址时会产生内存访问错误。
5.大数据结构的局部变量。


----------
# float与0值进行比较
const float EPSINON = 0.00001; 
fabs(a - b) < FLT_EPSILON；

----------

# 哪些函数不能被声明为虚函数
什么样的函数不能声明为虚函数？1）不能被继承的函数。2）不能被重写的函数。

1）普通函数

普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。

而多态体现在运行时绑定。通常通过基类指针指向子类对象实现多态。

2）友元函数

友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。

3）构造函数

首先说下什么是构造函数，构造函数是用来初始化对象的。假如子类可以继承基类构造函数，那么子类对象的构造将使用基类的构造函数，而基类构造函数并不知道子类的有什么成员，显然是不符合语义的。从另外一个角度来讲，多态是通过基类指针指向子类对象来实现多态的，在对象构造之前并没有对象产生，因此无法使用多态特性，这是矛盾的。因此构造函数不允许继承。

4）内联成员函数

我们需要知道内联函数就是为了在代码中直接展开，减少函数调用花费的代价。也就是说内联函数是在编译时展开的。而虚函数是为了实现多态，是在运行时绑定的。因此显然内联函数和多态的特性相违背。

5）静态成员函数

首先静态成员函数理论是可继承的。但是静态成员函数是编译时确定的，无法动态绑定，不支持多态，因此不能被重写，也就不能被声明为虚函数。

----------

# 重载与重写  
重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。  

重写(覆盖)：是指派生类中存在重新定义的函数。其函数名，参数列表，返回值类型，所有都必须同基类中被重写的函数一致。只有函数体不同（花括号内），派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。

重载和重写的区别：

（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。

（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。

（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。

# 内存泄露的原因：
内存泄漏产生的原因一般是三种情况： 

1. 分配完内存之后忘了回收； 

2. 程序Code有问题，造成没有办法回收； 

3. 某些API函数操作不正确，造成内存泄漏。 

检查：debug版本下_CrtCheckMemory。