# 调度算法
1、先来先服务调度算法FCFS  
2、短作业（进程）优先调度算法SJF（非抢占）/SPF（抢占）  
3、高优先权优先调度算法HPF  
4、基于时间片的轮转调度算法RR  
5、多级反馈队列算法FB  

![](https://img-blog.csdnimg.cn/20181110120751304.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poMTM0ODc=,size_16,color_FFFFFF,t_70)


----------
# IO多路复用
多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。

实现原理：用户将想要监视的文件描述符（File Descriptor）添加到select/poll/epoll函数中，由内核监视，函数阻塞。一旦有文件描述符就绪（读就绪或写就绪），或者超时（设置timeout），函数就会返回，然后该进程可以进行相应的读/写操作。


## poll,select和epoll区别

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

### select：
将文件描述符放入一个集合中，调用select时将集合从用户空间cpoy到内核空间。由内核根据就绪状态修改集合内容，集合大小有限制。采用水平出发机制，select函数返回后需要遍历集合找到就绪的fd。当fd数量增加时效率会线性下降。

（1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大  
（2）select支持的文件描述符数量太小了，集合大小有限制，默认是1024（32位）   
（3）同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大  



### poll
　poll的实现和select非常相似，只是描述fd集合的方式不同，poll使用pollfd结构（链表的方式）而不是select的fd_set结构，而使其没有连接数的限制，其他的都差不多。

### epoll

通过内核和用户空间共享内存，避免了不断复制的问题；epoll保证了每个fd在整个过程中只会拷贝一次。epoll_wait的工作实际上就是在这个就绪队列中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果。epoll所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048。  

epoll_create:创建内核事件表用来存放描述符和事件。它的数据结构为：struct eventpoll。其中包括了两个重要成员，一个是红黑树，也就是内核事件表。另一个重要成员是用于存放就绪事件的队列。

epoll_ctl:红黑树添加节点操作：ep_insert。红黑树移除节点操作：ep_remove。红黑树修改节点操作：ep_modify。每个节点都是一个描述符和事件的结构体。

epoll_wait：负责收集就绪事件。

注意：关于epoll_wait是如何收集就绪事件的，大致是这样一个思路：添加事件和描述符时，注册回调函数。当描述符上有事件就绪时，把描述符和事件添加到队列中。

epoll的两种工作方式：1.水平触发（LT）2.边缘触发（ET）   

LT模式：只要fd就绪，epoll_wait()就会触发通知。如果没有一次性读取完（如读写缓冲区太小），会将没有处理完的事件继续放回到就绪队列之中（即那个内核中的链表），一直进行通知处理。如果你不处理会一直通知你，如果系统中有大量不需要读写的fd,会大大降低读写效率。  
 
ET模式：fd就绪时，epoll_wait只会通知一次，若没有处理完会下次调用epoll_wait不会再通知你，除非触发第二次可读写事件。而若以后再也没有就绪的事件，那么剩余的那部分数据也会随之而丢失。这种模式效率更高。  
 
由此可见：ET模式的效率比LT模式的效率要高很多。只是如果使用ET模式，就要保证每次进行数据处理时，要将其处理完，不能造成数据丢失，这样对编写代码的人要求就比较高。 
注意：ET模式只支持非阻塞的读写：为了保证数据的完整性。

### 总结

（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。  
（3）当连接数较多并且有很多的不活跃连接时，epoll的效率比其它两者高很多；但是当连接数较少并且都十分活跃的情况下，由于epoll需要很多回调，因此性能可能低于其它两者。

# 字符串转换
字符减'0'可以到相应的整数。  

大写字母=小写字母-32 ；这个公式了。当然这里的32我也可以这么写‘Z’=‘z’-'空格'。因为空格的ASCII码是32对应的二进制编码。

# 线程和进程的区别

根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位

1 在开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

2 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）

3 内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。

4 包含关系：没有线程的进程可以看做是单线程的，如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

# 管道符和xargs 
管道：

利用Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推。

注意：管道左边命令的输入作为管道右边命令的输入(命令的输入是一定的)，不是参数，并不是所有命令都支持管道

例子：ls | grep a 查看当前目录下名称包含a的文件或文件夹

xargs：

把标准输入格式化为一行，作为后面的命令的命令行参数。  

例子：echo '--help' | xargs cat 等价于 cat --help


# sed与awk
sed是一个很好的文件处理工具，本身是一个管道命令，主要是以行为单位进行处理，可以将数据行进行替换、删除、新增、选取等特定工作，下面先了解一下sed的用法
sed命令行格式为：


	sed [-nefri] ‘command’ 输入文本 

awk语言的最基本功能是在文件或者字符串中基于指定规则浏览和抽取信息，awk抽取信息后，才能进行其他文本操作。完整的awk脚本通常用来格式化文本文件中的信息。

通常，awk是以文件的一行为处理单位的。awk每接收文件的一行，然后执行相应的命令，来处理文本。

	awk '{pattern + action}' {filenames}
尽管操作可能会很复杂，但语法总是这样，其中 pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令。花括号（{}）不需要在程序中始终出现，但它们用于根据特定的模式对一系列指令进行分组。 pattern就是要表示的正则表达式，用斜杠括起来。

# find与grep
find:侧重于在目录下查找文件。在Linux中可以使用find命令在指定的目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名，当使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件，并将查找到的文件进行全部显示。

grep:侧重于在文件中查找关键字。Linux中grep命令用于查找文件中符合条件的字符串，grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合指定的范本样式，预设grep指令将会把含有范本样式的哪一列显示出来，若不指定任何文件名称，或是所给与的文件名”-”，则grep将会从标准输入设备读取数据。

# 进程和线程
## 进程和线程有什么区别？
- 进程（Process）是系统进行资源分配和调度的基本单位，线程（Thread）是CPU调度和分派的基本单位；
- 线程依赖于进程而存在，一个进程至少有一个线程；
- 进程有自己的独立地址空间，线程共享所属进程的地址空间；
- 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，和其他线程共享本进程的相关资源如内存、I/O、cpu等；
- 在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销远大于线程切换的开销；
- 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；
- 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮

进程操作代码实现，可以参考：[多进程 - 廖雪峰的官方网站](https://www.liaoxuefeng.com/wiki/1016959663602400/1017628290184064)



### 线程crash一定会导致进程崩溃吗？
大概率会崩溃但不一定。线程崩溃的本质就是内存出错。而内存出错有时不会引起其他线程出错的，因为崩溃的线程，也就是出错的内存有时侯没有被其他线程访问，也就不会产生问题，但有时候会打乱其他线程的内存就会导致进程整个崩溃。

### 同一进程中的线程可以共享哪些数据？

- 进程代码段
- 进程的公有数据（全局变量、静态变量...）
- 进程打开的文件描述符
- 进程的当前目录
- 信号处理器/信号处理函数：对收到的信号的处理方式
- 进程ID与进程组ID


### 线程独占哪些资源？

- 线程ID
- 一组寄存器的值
- 线程自身的栈（堆是共享的）
- 错误返回码：线程可能会产生不同的错误返回码，一个线程的错误返回码不应该被其它线程修改；
- 信号掩码/信号屏蔽字(Signal mask)：表示是否屏蔽/阻塞相应的信号（SIGKILL,SIGSTOP除外）

### 线程的栈中都存储哪些数据？
每个线程包含一个栈区，栈中只保存基础数据类型的对象（比如int i=1中1就是基础类型的对象）和自定义对象的引用(不是对象)，而真实对象都存放在堆区中。


### 小问题：
1. 浏览器开启一个新的page是进程还是线程（进程，进程间资源隔离，更安全健壮，但进程开销更大）


## 进程间通信方式
详解：https://imageslr.github.io/2020/02/26/ipc.html

1. **管道（匿名管道）**  
管道是一种半双工的通信方式，数据只能单向流动，只适用于具有亲缘关系的进程，上游进程往管道中写入数据，下游进程从管道中接收数据。如果想实现双方通信，那么需要建立两个管道。管道适合于传输大量信息。管道发送的内容是以字节为单位的，没有格式的字节流。     
管道是一种特殊的文件系统，是由内核管理的一个缓冲区，缓冲区被设计成为环形的数据结构，以便管道可以被循环利用（循环队列）。   
管道命令，在 Linux Shell 中经常使用，一般，我们使用管道操作符 | 来表示两个命令之间的数据通信。

2. **命名管道（FIFO）**  
命名管道（FIFO）可用于没有亲缘的进程间。Pipe 和 FIFO 除了建立、打开、删除的方式不同外，二者几乎一模一样。
命名管道一旦建立，任何有访问权的进程都可以通过文件名将其打开和进行读写，而不局限于父子进程。
建立命名管道时，会在磁盘中创建一个索引节点，命名管道的名字就相当于索引节点的文件名。索引节点设置了进程的访问权限，但是没有数据块。命名管道实质上也是通过内核缓冲区来实现数据传输。有访问权限的进程，可以通过磁盘的索引节点来读写这块缓冲区。

3. **信号**   
信号是 Linux 系统响应某些条件而产生的一个事件，由操作系统事先定义，接收到该信号的进程可以采取自定义的行为。这是一种“订阅-发布”的模式。  
（1）硬件来源。如按下 CTRL+C、除 0、非法内存访问等等
（2）软件来源。如 Kill 命令、Alarm Clock 超时、当 Reader 中止之后又向管道写数据，等等。  
溢出、非法内存访问（越界）、非法指令等也都属于硬件中断，由操作系统处理。操作系统会将这些硬件异常包装成“信号”发送给进程。如果进程不处理这几个异常信号，那么默认的行为就是挂掉。
信号的发送和接受通过信号队列来实现，接受信号之后可以处理信号，忽略信号，不处理也不忽略。

4. **信号量**   
信号量是一种特殊的变量，对它的操作都是原子的，有两种操作：V（signal()）和 P（wait()）。V 操作会增加信号标 S 的数值，P 操作会减少它。V(S)：如果有其他进程因等待 S 而被挂起，就让它恢复运行，否则 S 加 1。P(S)：如果 S 为 0，则挂起进程，否则 S 减 1。
如果信号量只有二进制的 0 或 1，称为二进制信号量（binary semaphore）。在 Linux 系统中，二进制信号量又称互斥锁（Mutex）。信号量可以用于实现进程或线程的互斥和同步。信号量在底层的实现是通过硬件提供的原子指令，如 Test And Set、Compare And Swap 等。

5. **消息队列**  
消息队列是一个消息的链表，保存在内核中。消息队列中的每个消息都是一个数据块，具有特定的格式。操作系统中可以存在多个消息队列，每个消息队列有唯一的 key，称为消息队列标识符。  
消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据，但消息队列仍然有大小限制。  
消息队列和管道相比，相同点在于二者都是通过发送-接收的方式进行通信，并且数据都有最大长度限制。不同点在于消息队列的数据是有格式的，并且取消息进程可以选择接收特定类型的消息，而不是像管道中那样默认全部接收。

6. **套接字**  
不同的计算机的进程之间通过 socket 通信，也可用于同一台计算机的不同进程
需要通信的进程之间首先要各自创建一个 socket，内容包括主机地址与端口号，声明自己接收来自某端口地址的数据
进程通过 socket 把消息发送到网络层中，网络层通过主机地址将其发到目的主机，目的主机通过端口号发给对应进程

7. **共享内存**  
共享内存顾名思义，允许两个或多个进程共享同一段物理内存。不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它。不同进程可以通过向共享内存端读写数据来交换信息。  
共享内存的优点是简单且高效，访问共享内存区域和访问进程独有的内存区域一样快，原因是不需要系统调用，不涉及用户态到内核态的转换，也不需要对数据不必要的复制。  
共享内存的缺点是存在并发问题，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。  


### 并发、并行、异步的区别？


并发：在一个时间段中同时有多个程序在运行，但其实任一时刻，只有一个程序在CPU上运行，宏观上的并发是通过不断的切换实现的；

多线程：并发运行的一段代码。是实现异步的手段

并行（和串行相比）：在多CPU系统中，多个程序无论宏观还是微观上都是同时执行的

异步（和同步相比）：同步是顺序执行，异步是在等待某个资源的时候继续做自己的事

### 进程有哪几种状态？


- 就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源
- 运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数
- 阻塞状态： 进程等待某种条件，在条件满足之前无法执行


### 线程同步有哪些方式？

> 为什么需要线程同步：线程有时候会和其他线程共享一些资源，比如内存、数据库等。当多个线程同时读写同一份共享资源的时候，可能会发生冲突。因此需要线程的同步，多个线程按顺序访问资源。

- **互斥量** Mutex：互斥量是内核对象，只有拥有互斥对象的线程才有访问互斥资源的权限。因为互斥对象只有一个，所以可以保证互斥资源不会被多个线程同时访问；当前拥有互斥对象的线程处理完任务后必须将互斥对象交出，以便其他线程访问该资源；
- **信号量** Semaphore：信号量是内核对象，它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。信号量对象保存了**最大资源计数**和**当前可用资源计数**，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号，如果为0，则将线程放入一个队列中等待。线程处理完共享资源后，应在离开的同时通过```ReleaseSemaphore```函数将当前可用资源数加1。如果信号量的取值只能为0或1，那么信号量就成为了互斥量；
- **事件** Event：允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。事件分为手动重置事件和自动重置事件。手动重置事件被设置为激发状态后，会唤醒所有等待的线程，而且一直保持为激发状态，直到程序重新把它设置为未激发状态。自动重置事件被设置为激发状态后，会唤醒**一个**等待中的线程，然后自动恢复为未激发状态。
- **临界区** Critical Section：任意时刻只允许一个线程对临界资源进行访问。拥有临界区对象的线程可以访问该临界资源，其它试图访问该资源的线程将被挂起，直到临界区对象被释放。

### 线程安全问题
当多个线程同时访问临界资源（一个对象，对象中的属性，一个文件，一个数据库等）时，就可能会产生线程安全问题。    

解决方法：基本上所有的并发模式在解决线程安全问题上，都采用“序列化访问临界资源”的方案，即在同一时刻，只能有一个线程访问临界资源，也称同步互斥访问。通常来说，是在访问临界资源的代码前面加上一个锁，当访问完临界资源后释放锁，让其他线程继续访问

### 线程与协程
协程（Coroutines）是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。
协程不是被操作系统内核所管理的，而是完全由程序所控制，也就是在用户态执行。这样带来的好处是性能大幅度的提升，因为不会像线程切换那样消耗资源。  
协程不是进程也不是线程，而是一个**特殊的函数**，这个函数可以在某个地方挂起，并且可以重新在挂起处外继续运行。所以说，协程与进程、线程相比并不是一个维度的概念。  
线程内的协程一定是串行的，当一个协程运行时其他协程必须挂起。
协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

区别：

1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程。

2) 线程进程都是同步机制，而协程则是异步。

3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态。

4）线程是抢占式，而协程是非抢占式的，所以需要用户自己释放使用权来切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。

5）协程并不是取代线程, 而且抽象于线程之上, 线程是被分割的CPU资源, 协程是组织好的代码流程, 协程需要线程来承载运行, 线程是协程的资源, 但协程不会直接使用线程, 协程直接利用的是执行器(Interceptor), 执行器可以关联任意线程或线程池, 可以使当前线程, UI线程, 或新建新程.。

6）线程是协程的资源。协程通过Interceptor来间接使用线程这个资源。




### 互斥量和临界区的区别

互斥量是可以命名的，可以用于不同进程之间的同步；而临界区只能用于同一进程中线程的同步。创建互斥量需要的资源更多，因此临界区的优势是速度快，节省资源。

# 死锁

### 什么是死锁？

在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。

### 死锁产生的必要条件？
- **互斥**：一个资源一次只能被一个进程使用；
- **占有并等待**：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；
- **非抢占**：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；
- **循环等待**：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。

### 死锁有哪些处理方法？
<details>
<summary>鸵鸟策略</summary>

直接忽略死锁。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
</details>

<details>
<summary>死锁预防</summary>

基本思想是破坏形成死锁的四个必要条件：
- 破坏互斥条件：允许某些资源同时被多个进程访问。但是有些资源本身并不具有这种属性，因此这种方案实用性有限；
- 破坏占有并等待条件：
    - 实行资源预先分配策略（当一个进程开始运行之前，必须一次性向系统申请它所需要的全部资源，否则不运行）；
    - 或者只允许进程在没有占用资源的时候才能申请资源（申请资源前先释放占有的资源）；
    - 缺点：很多时候无法预知一个进程所需的全部资源；同时，会降低资源利用率，降低系统的并发性；
- 破坏非抢占条件：允许进程强行抢占被其它进程占有的资源。会降低系统性能；
- 破坏循环等待条件：对所有资源统一编号，所有进程对资源的请求必须按照序号递增的顺序提出，即只有占有了编号较小的资源才能申请编号较大的资源。这样避免了占有大号资源的进程去申请小号资源。
</details>

<details>
<summary>死锁避免</summary>

动态地检测资源分配状态，以确保系统处于安全状态，只有处于安全状态时才会进行资源的分配。所谓安全状态是指：即使所有进程突然请求需要的所有资源，也能存在某种对进程的资源分配顺序，使得每一个进程运行完毕。

> 银行家算法
</details>

<details>
<summary>死锁解除</summary>

> 如何检测死锁：检测有向图是否存在环；或者使用类似死锁避免的检测算法。

死锁解除的方法：  

- 利用抢占：挂起某些进程，并抢占它的资源。但应防止某些进程被长时间挂起而处于饥饿状态；  
- 利用回滚：让某些进程回退到足以解除死锁的地步，进程回退时自愿释放资源。要求系统保持进程的历史信息，设置还原点；  
- 利用杀死进程：强制杀死某些进程直到死锁解除为止，可以按照优先级进行。   
</details>

## 物理内存和虚拟内存

### 区别与联系  
当每个进程创建的时候，内核会为进程分配4G的虚拟内存，当进程还没有开始运行时，这只是一个内存布局。实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射）。这个时候数据和代码还是在磁盘上的。当运行到对应的程序时，进程去寻找页表，发现页表中地址没有存放在物理内存上，而是在磁盘上，于是发生缺页异常，于是将磁盘上的数据拷贝到物理内存中。

另外在进程运行过程中，要通过malloc来动态分配内存时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。

虚拟内存的优点是让程序可以获得更多的可用内存，提高了内存的利用率。




### 有哪些页面置换算法？
在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘中来腾出空间。页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

- **最佳页面置换算法**OPT（Optimal replacement algorithm）：置换以后不需要或者最远的将来才需要的页面，是一种理论上的算法，是最优策略；
- **先进先出**FIFO：置换在内存中驻留时间最长的页面。缺点：有可能将那些经常被访问的页面也被换出，从而使缺页率升高；
- **第二次机会算法**SCR：按FIFO选择某一页面，若其访问位为1，给第二次机会，并将访问位置0；
- **时钟算法** Clock：SCR中需要将页面在链表中移动（第二次机会的时候要将这个页面从链表头移到链表尾），时钟算法使用环形链表，再使用一个指针指向最老的页面，避免了移动页面的开销；
- **最近未使用算法**NRU（Not Recently Used）：检查访问位R、修改位M，优先置换R=M=0，其次是（R=0, M=1）；
- **最近最少使用算法**LRU（Least Recently Used）：置换出未使用时间最长的一页；实现方式：维护时间戳，或者维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。
- **最不经常使用算法**NFU：置换出访问次数最少的页面

### 什么是虚拟内存？
每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。虚拟内存的优点是让程序可以获得更多的可用内存

### 硬链接和软连接
软连接：相当于创建一个路径的快捷方式。A是B的软链接（A和B都是文件名），A的目录项中的inode节点号与B的目录项中的inode节点号不相同，A和B指向的是两个不同的inode，继而指向两块不同的数据块。但是A的数据块中存放的只是B的路径名（可以根据这个找到B的目录项）。A和B之间是“主从”关系，如果B被删除了，A仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。  

硬链接:相当于指向同一个节点的两个文件，但又不同于copy。A是B的硬链接（A和B都是文件名），则A的目录项中的inode节点号与B的目录项中的inode节点号相同，即一个inode节点对应两个不同的文件名，两个文件名指向同一个文件，A和B对文件系统来说是完全平等的。如果删除了其中一个，对另外一个没有影响。每增加一个文件名，inode节点上的链接数增加一，每删除一个对应的文件名，inode节点上的链接数减一，直到为0，inode节点和对应的数据块被回收。注：文件和文件名是不同的东西，rm A删除的只是A这个文件名，而A对应的数据块（文件）只有在inode节点链接数减少为0的时候才会被系统回收。


# 同步和异步的区别
同步：可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。同步会造成阻塞。  

异步：执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。异步不会阻塞。

#KILL杀不掉的进程
kill -9 发送SIGKILL信号给进程，将其终止，只有处于用户态的进程才可以用“kill”命令将其终止。但对于以下两种情况不适用

1.该进程是僵尸进程（STAT z），此时进程已经释放所有的资源，但是没有被父进程释放。僵尸进程要等到父进程结束，或者重启系统才可以被释放。

2.进程处于“核心态”，并且在等待不可获得的资源，处于“核心态 ”的资源默认忽略所有信号。只能重启系统。

3.init进程不可杀。 

## fork和vfork的区别

fork和vfork分别调用了sys_fork、sys_vfork，最终都调用了do_fork函数。

进程的四要素

- 程序代码（不一定是一个进程所专有的）  
- 专用系统堆栈空间
- 进程控制块
- 专用的
- 空间（地址空间）
### 1).fork()

fork()函数调用成功：返回两个值； 父进程：返回子进程的PID；子进程：返回0；失败：返回-1；

fork 创造的子进程复制了父亲进程的资源（写时复制技术），包括进程四要素。

开始时，两者的虚拟空间不同，但其对应的物理空间是同一个。有需要时才写时复制。

一般子进程先调度，但子父线程自由执行。

### 2).vfork

vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。 vfork是一个过时的应用,vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功，所以设计了vfork。现在fork使用了COW机制，唯一的代价仅仅是复制父进程页表的代价，所以vfork不应该出现在新的代码之中。

虚地址也是相同的

进程阻塞，直到子进程执行了exec()或者exit()

缺少“专用的用户空间”
### 总结：

1. fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段



1. fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。



1. vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。



1. 当需要改变共享数据段中变量的值，则拷贝父进程。

## 僵尸进程和孤儿进程
https://www.cnblogs.com/Anker/p/3271773.html   
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。   
孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，孤儿进程没有什么危害。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。  
僵尸进程危害：如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。
解决方法：通过kill将僵尸进程变为孤儿进程。  


## 文件描述符  
文件描述符是一个非负整数，当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符

文件描述符的变化范围是0~OPEN_MAX-1，其中012是固定的：  

	描述符0（STDIN_FILENO）与进程的标准输入关联
	描述符1（STDOUT_FILENO）与进程的标准输出关联
	描述符2（STDERR_FILENO）与进程的标准错误关联

文件描述符的变化范围几乎是无限的，只受到以下几种约束：

1.系统配置的存储器总量
2.整型的字长
3.系统管理员所位置的软限制和硬限制

## 用户态和内核态  
内核态和用户态是操作系统的两种运行级别，用于区分不同程序的不同权利。内核态就是拥有资源多的状态，或者说访问资源多的状态，也称为特权态。相对来说，用户态就是非特权态，访问的资源将受到限制。如果一个程序运行在特权态，该程序就可以访问计算机的任何资源，它的资源访问权限不受限制。如果一个程序运行在用户态，其资源需求将受到各种限制。如：要访问操作系统的内核数据结构，如进程表，则需要在特选态下才能办到。如果要访问用户程序里的数据，在用户态即可。

- 用户栈、内核栈

内核在创建进程的时候，在创建task_struct的同时，会为进程创建相应的堆栈。每一个进程都有两个栈，一个用户栈，存在于用户空间；一个内核栈，存在于内核空间。当进程在用户空间运行时，CPU堆栈指针寄存器里面的内容都是用户栈地址，使用用户栈；当进程在内核空间时，CPU堆栈指针寄存器里面的内容是内核栈空间地址，使用内核栈。

​ 当进程因为中断或者系统调用陷入到内核态时，进程所使用的堆栈也要从用户栈转到内核栈。进程陷入到内核态后，先把用户态堆栈的地址保存在内核栈之中，然后设置堆栈指针寄存器的内容为内核栈的地址，这样就完成了用户栈向内核栈的转换；当进程从内核态恢复到用户态之后时，在内核态之后的最后将保存在内核栈里面的用户栈的地址恢复到堆栈指针寄存器即可。这样就实现了用户栈和内核栈的互转。

​ 那么，知道从内核转到用户态时，用户栈的地址是在陷入内核的时候保存在内核栈里面的，但是在陷入内核的时候，如何知道内核栈的地址？关键在进程从用户态转到内核态的时候，进程的内核栈总是空的。这是因为当进程在用户态运行时，使用的用户栈，当进程陷入到内核态时，内核保存进程在内核态运行的相关信息，但是一旦进程返回到用户态后，内核栈中保存的信息无效，会全部恢复，因此每次进程从用户态陷入内核的时候得到的内核栈都是空的。所以在进程陷入内核的时候，直接把内核栈的栈顶地址给堆栈指针寄存器就可以了。

### 陷入内核的方式 
- 发生系统调用时，这是用户态进程主动切换内核态的方式。   
用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。而系统调用的机制，其核心仍是使用了操作系统为用户特别开发的一个中断机制来实现的，即软中断。  
- 产生异常时    
​当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，如缺页异常。
- 外设产生中断时  

## 高端内存和低端内存  
高端内存(ZONE_HIGHEM)，对于内核空间而言高于896M的空间称为高端内存，低于896M的自然就可以称为低端内存
https://blog.csdn.net/yuzhihui_no1/article/details/46711601   

为了合理的利用逻辑4G空间，Linux采用了3：1的策略，即内核占用1G的线性地址空间，用户占用3G的线性地址空间。所以用户进程的地址范围从0~3G，内核地址范围从3G~4G，也就是说，内核空间只有1G的逻辑线性地址空间。

如果Linux物理内存小于1G的空间，通常内核把物理内存与其地址空间做了线性映射，也就是一一映射，这样可以提高访问速度。但是，当Linux物理内存超过1G时，线性访问机制就不够用了，因为只能有1G的内存可以被映射，剩余的物理内存无法被内核管理，所以，为了解决这一问题，Linux把内核地址分为线性区和非线性区两部分，线性区规定最大为896M，剩下的128M为非线性区。从而，线性区映射的物理内存成为低端内存，剩下的物理内存被成为高端内存。与线性区不同，非线性区不会提前进行内存映射，而是在使用时动态映射。

假设物理内存为2G，则低段的896M为低端内存，通过线性映射给内核使用，其他的1128M物理内存为高端内存，可以被内核的非线性区使用。由于要使用128M非线性区来管理超过1G的高端内存，所以通常都不会映射，只有使用时才使kmap映射，使用完后要尽快用kunmap释放。

